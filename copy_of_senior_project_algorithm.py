# -*- coding: utf-8 -*-
"""Copy of Senior Project Algorithm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bfjFkAXn8YEcWBZ0ZUS5s785MuzuDc3U
"""

"""This code implements Javascript to take and store a live image using your device's camera"""

from IPython.display import display, Javascript
from google.colab.output import eval_js
from base64 import b64decode

def take_photo(filename='photo.jpg', quality=0.8):
  js = Javascript('''
    async function takePhoto(quality) {
      const div = document.createElement('div');
      const capture = document.createElement('button');
      capture.textContent = 'Capture';
      div.appendChild(capture);

      const video = document.createElement('video');
      video.style.display = 'block';
      const stream = await navigator.mediaDevices.getUserMedia({video: true});

      document.body.appendChild(div);
      div.appendChild(video);
      video.srcObject = stream;
      await video.play();

      // Resize the output to fit the video element.
      google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

      // Wait for Capture to be clicked.
      await new Promise((resolve) => capture.onclick = resolve);

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      stream.getVideoTracks()[0].stop();
      div.remove();
      return canvas.toDataURL('image/jpeg', quality);
    }
    ''')
  display(js)
  data = eval_js('takePhoto({})'.format(quality))
  binary = b64decode(data.split(',')[1])
  with open(filename, 'wb') as f:
    f.write(binary)
  return filename

"""This code calls the previous code segment"""

from IPython.display import Image

try:
  filename = take_photo()
  print('Saved to {}'.format(filename))

  # Show the image which was just taken.
  display(Image(filename))
except Exception as err:
  # Errors will be thrown if the user does not have a webcam or if they do not
  # grant the page permission to access it.
  print(str(err))

# Get photo data from Google Drive if necessary
from google.colab import drive
drive.mount('/content/drive')

"""This code activates the training model for the UNDERWATER SIDE POV of the swimmer"""

from keras.models import load_model
from PIL import Image, ImageOps
import numpy as np
import time

# Load the model
model = load_model('SIDE POV MODEL PATHNAME')
labels = [line for line in open("SIDE POV LABELS PATHNAME")]

# Create the array of the right shape to feed into the keras model
# The 'length' or number of images you can put into the array is
# determined by the first position in the shape tuple, in this case 1.
data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)
# Replace this with the path to your image
image = Image.open('IMAGE PATHNAME')
#resize the image to a 224x224 with the same strategy as in TM2:
#resizing the image to be at least 224x224 and then cropping from the center
size = (224, 224)
image = ImageOps.fit(image, size, Image.ANTIALIAS)

#turn the image into a numpy array
image_array = np.asarray(image)
# Normalize the image
normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1
# Load the image into the array
data[0] = normalized_image_array

# run the inference
prediction = model.predict(data)
print(prediction)
choice = np.argmax(prediction)
print(choice)

if choice == 0:
  print("The algorithm has predicted that you have satisfactory technique")
  print("Based on this POV, the algorithm predicts that you have good elbow and knee flexion, you are facing downwards, you are parallel to the pool floor and water surface, and you are not over-rotating to the side")
elif choice == 1:
  print("The algorithm has predicted that your technique needs improvement")
  print("This may be because you are not flexing your elbows and knees enough, your body slants and sinks into the water instead of staying straight, facing forwards instead of downwards, or rotating too much to the side")
else:
  print("Are you sure you took a picture of swimming? Make sure your photo is from the correct POV (under the water surface in front of the swimmer) and is clear of any noise and is not blurry")

print("In order to calculate your biomechanical efficiency, your pulse needs to be measured")
time.sleep(3)

def pulse():
  print("Touch either your carotid or radial artery to measure pulse")
  time.sleep(3)
  print("Start counting your pulse in")
  print("3...")
  time.sleep(1)
  print("2...")
  time.sleep(1)
  print("1...")
  time.sleep(1)
  print("Go")
  for i in range(1, 60):
    print(i)
    time.sleep(1)
  pulse = int(input("How many heart beats/pulses did you count? "))
  return pulse

def work_input(pulse):
  time = float(input("How many minutes did you swim for (give answer in decimal form)? "))
  mass = int(input("What is the mass of the user in kg?: "))
  oxygen_consumption = (pulse * 2.67 + 65.45) * mass
  work_input = oxygen_consumption * 4.825 / 1000 * 4185 * time
  return work_input

def work_output():
  distance = int(input("How many meters did you swim for? "))
  force = 40.0 * (10.0 * choice)
  work_output = force * distance
  return work_output

p = pulse()
wi = work_input(p)
wo = work_output(p)
efficiency = wo / wi * 100.0

print("Your work input is: " + str(wi) + "Joules")
time.sleep(1)
print("Your work output is: " + str(wo) + "Joules")
time.sleep(1)
print("Your efficiency is : " + str(efficiency) + "%")

if (efficiency < 3):
  print("If you see that your efficiency is nearly 0% or beneath 3%, don't fret! Humans are not evolved to be swimmers. However, swimmers can improve their effiency, and even a 0.5% increase makes a HUGE difference!")
elif (efficiency < 7):
  print("If you see that your efficiency is beyond 3%, you are already pretty good. See if you can get even better!")
else:
  print("Wow! You're a pro!")

time.sleep(3)
print("Thanks for using this program!")

"""This code activates the training model for the UNDERWATER FRONT POV of the swimmer"""

from keras.models import load_model
from PIL import Image, ImageOps
import numpy as np
import time

# Load the model
model = load_model('FRONT POV MODEL PATHNAME')
labels = [line for line in open("FRONT POV LABELS PATHNAME")]

# Create the array of the right shape to feed into the keras model
# The 'length' or number of images you can put into the array is
# determined by the first position in the shape tuple, in this case 1.
data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)
# Replace this with the path to your image
image = Image.open('IMAGE PATHNAME')
#resize the image to a 224x224 with the same strategy as in TM2:
#resizing the image to be at least 224x224 and then cropping from the center
size = (224, 224)
image = ImageOps.fit(image, size, Image.ANTIALIAS)

#turn the image into a numpy array
image_array = np.asarray(image)
# Normalize the image
normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1
# Load the image into the array
data[0] = normalized_image_array

# run the inference
prediction = model.predict(data)
print(prediction)
choice = np.argmax(prediction)
print(choice)

if choice == 0:
  print("The algorithm has predicted that you have satisfactory technique")
  print("Based on this POV, the algorithm predicts that you have good elbow flexion, you are facing downwards, you are not crossing the central axis, you are not over-rotating to the side, and you have good shoulder hinges")
elif choice == 1:
  print("The algorithm has predicted that your technique needs improvement")
  print("This may be because you are not flexing your elbows, you might be doing vertical (straight hand) arm cycles, facing forwards instead of downwards, rotating too much to the side, or are reaching across too much")
else:
  print("Are you sure you took a picture of swimming? Make sure your photo is from the correct POV (under the water surface in front of the swimmer) and is clear of any noise and is not blurry")

print("In order to calculate your biomechanical efficiency, your pulse needs to be measured")
time.sleep(3)

def pulse():
  print("Touch either your carotid or radial artery to measure pulse")
  time.sleep(3)
  print("Start counting your pulse in")
  print("3...")
  time.sleep(1)
  print("2...")
  time.sleep(1)
  print("1...")
  time.sleep(1)
  print("Go")
  for i in range(1, 60):
    print(i)
    time.sleep(1)
  pulse = int(input("How many heart beats/pulses did you count? "))
  return pulse

def work_input(pulse):
  time = float(input("How many minutes did you swim for (give answer in decimal form)? "))
  mass = int(input("What is the mass of the user in kg?: "))
  oxygen_consumption = (pulse * 2.67 + 65.45) * mass
  work_input = oxygen_consumption * 4.825 / 1000 * 4185 * time
  return work_input

def work_output():
  distance = int(input("How many meters did you swim for? "))
  force = 40.0 * (10.0 * choice)
  work_output = force * distance
  return work_output

p = pulse()
wi = work_input(p)
wo = work_output(p)
efficiency = wo / wi * 100.0

print("Your work input is: " + str(wi) + "Joules")
time.sleep(1)
print("Your work output is: " + str(wo) + "Joules")
time.sleep(1)
print("Your efficiency is : " + str(efficiency) + "%")

if (efficiency < 3):
  print("If you see that your efficiency is nearly 0% or beneath 3%, don't fret! Humans are not evolved to be swimmers. However, swimmers can improve their effiency, and even a 0.5% increase makes a HUGE difference!")
elif (efficiency < 7):
  print("If you see that your efficiency is beyond 3%, you are already pretty good. See if you can get even better!")
else:
  print("Wow! You're a pro!")

time.sleep(3)
print("Thanks for using this program!")

"""This code activates the training model for the ABOVE WATER POV of the swimmer"""

from keras.models import load_model
from PIL import Image, ImageOps
import numpy as np
import time

# Load the model
model = load_model('/content/top_POV_model.h5')
labels = [line for line in open("/content/top_POV_labels.txt")]

# Create the array of the right shape to feed into the keras model
# The 'length' or number of images you can put into the array is
# determined by the first position in the shape tuple, in this case 1.
data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)
# Replace this with the path to your image
image = Image.open('/content/photo.jpg')
#resize the image to a 224x224 with the same strategy as in TM2:
#resizing the image to be at least 224x224 and then cropping from the center
size = (224, 224)
image = ImageOps.fit(image, size, Image.ANTIALIAS)

#turn the image into a numpy array
image_array = np.asarray(image)
# Normalize the image
normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1
# Load the image into the array
data[0] = normalized_image_array

# run the inference
prediction = model.predict(data)
print(prediction)
choice = 1
print(choice)

if choice == 0:
  print("The algorithm has predicted that you have satisfactory technique")
  print("Based on this POV, the algorithm predicts that you have good elbow flexion, your are facing downwards, and have good flutter kicks")
elif choice == 1:
  print("The algorithm has predicted that your technique needs improvement")
  print("This may be because you are not flexing your elbows, you might be doing vertical (straight hand) arm cycles, facing forwards instead of downwards, or have weak flutter kicks that are not breaching the water surface")
else:
  print("Are you sure you took a picture of swimming? Make sure your photo is from the correct POV (above the water surface) and is clear of any noise and is not blurry")

print("In order to calculate your biomechanical efficiency, your pulse needs to be measured")
time.sleep(3)

def pulse():
  print("Touch either your carotid or radial artery to measure pulse")
  time.sleep(3)
  print("Start counting your pulse in")
  print("3...")
  time.sleep(1)
  print("2...")
  time.sleep(1)
  print("1...")
  time.sleep(1)
  print("Go")
  for i in range(1, 60):
    print(i)
    time.sleep(1)
  pulse = int(input("How many heart beats/pulses did you count? "))
  return pulse

def work_input(pulse):
  time = float(input("How many minutes did you swim for (give answer in decimal form)? "))
  mass = int(input("What is the mass of the user in kg?: "))
  oxygen_consumption = (pulse * 2.67 + 65.45) * mass
  work_input = oxygen_consumption * 4.825 / 1000 * 4185 * time
  return work_input

def work_output():
  distance = int(input("How many meters did you swim for? "))
  force = 40.0 * (10.0 * choice)
  work_output = force * distance
  return work_output

p = pulse()
wi = work_input(p)
wo = work_output()
efficiency = wo / wi * 100.0

print("Your work input is: " + str(wi) + "Joules")
time.sleep(1)
print("Your work output is: " + str(wo) + "Joules")
time.sleep(1)
print("Your efficiency is : " + str(efficiency) + "%")

if (efficiency < 3):
  print("If you see that your efficiency is nearly 0% or beneath 3%, don't fret! Humans are not evolved to be swimmers. However, swimmers can improve their effiency, and even a 0.5% increase makes a HUGE difference!")
elif (efficiency < 7):
  print("If you see that your efficiency is beyond 3%, you are already pretty good. See if you can get even better!")
else:
  print("Wow! You're a pro!")

time.sleep(3)
print("Thanks for using this program!")